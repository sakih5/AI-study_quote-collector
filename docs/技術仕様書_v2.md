# 技術仕様書 v2.0

## 1. システムアーキテクチャ

### 1.1 技術スタック

#### フロントエンド
- **フレームワーク**: Next.js 14 (App Router)
- **言語**: TypeScript 5.x
- **UIライブラリ**: Tailwind CSS 3.x
- **状態管理**: React Context API + hooks
- **フォーム管理**: React Hook Form
- **バリデーション**: Zod
- **OCR**: Tesseract.js 5.x

#### バックエンド
- **BaaS**: Supabase (PostgreSQL 15)
- **認証**: Supabase Auth
- **ストレージ**: Supabase Storage
- **API**: Next.js API Routes

#### インフラ
- **ホスティング**: Vercel
- **ドメイン**: Vercel Domains
- **CDN**: Vercel Edge Network

#### 開発ツール
- **パッケージ管理**: npm / pnpm
- **リンター**: ESLint
- **フォーマッター**: Prettier
- **テスト**: Vitest (単体テスト), Playwright (E2E)
- **CI/CD**: GitHub Actions

---

## 2. プロジェクト構成

### 2.1 ディレクトリ構造

```
抜き書きアプリ/
├── app/
│   ├── (auth)/
│   │   ├── login/
│   │   └── callback/
│   ├── (main)/
│   │   ├── layout.tsx
│   │   ├── page.tsx              # ホーム画面
│   │   ├── settings/
│   │   │   ├── page.tsx          # 設定画面
│   │   │   └── tags/
│   │   │       └── page.tsx      # タグ管理画面
│   │   └── components/
│   │       ├── QuoteCard.tsx
│   │       ├── QuoteModal.tsx
│   │       ├── OCRTextSelector.tsx
│   │       └── ...
│   └── api/
│       ├── activities/
│       ├── books/
│       ├── sns-users/
│       ├── tags/
│       ├── quotes/
│       ├── ocr/
│       └── export/
├── lib/
│   ├── supabase/
│   │   ├── client.ts
│   │   ├── server.ts
│   │   └── types.ts
│   ├── ocr/
│   │   └── tesseract.ts
│   ├── scraping/
│   │   ├── amazon.ts
│   │   └── google-search.ts
│   └── utils/
│       ├── csv-export.ts
│       └── validators.ts
├── components/
│   ├── ui/                       # 共通UIコンポーネント
│   ├── layouts/
│   └── ...
├── public/
│   └── assets/
├── styles/
│   └── globals.css
├── types/
│   └── index.ts
├── .env.local
├── .eslintrc.json
├── .prettierrc
├── next.config.js
├── package.json
├── tsconfig.json
└── README.md
```

---

## 3. OCR実装

### 3.1 Tesseract.js

#### 3.1.1 基本実装

```typescript
// lib/ocr/tesseract.ts
import Tesseract from 'tesseract.js';

export interface OCRWord {
  text: string;
  confidence: number;
  bbox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
}

export interface OCRLine {
  text: string;
  bbox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  words: OCRWord[];
}

export interface OCRResult {
  text: string;
  words: OCRWord[];
  lines: OCRLine[];
}

export async function performOCR(
  imageUrl: string,
  language: string = 'jpn'
): Promise<OCRResult> {
  const { data } = await Tesseract.recognize(imageUrl, language, {
    logger: (m) => {
      if (m.status === 'recognizing text') {
        console.log(`OCR進行中: ${Math.round(m.progress * 100)}%`);
      }
    },
  });

  return {
    text: data.text,
    words: data.words.map((w) => ({
      text: w.text,
      confidence: w.confidence / 100,
      bbox: w.bbox,
    })),
    lines: data.lines.map((l) => ({
      text: l.text,
      bbox: l.bbox,
      words: l.words.map((w) => ({
        text: w.text,
        confidence: w.confidence / 100,
        bbox: w.bbox,
      })),
    })),
  };
}
```

#### 3.1.2 画像前処理（精度向上）

```typescript
// lib/ocr/preprocess.ts
export function preprocessImage(canvas: HTMLCanvasElement): HTMLCanvasElement {
  const ctx = canvas.getContext('2d')!;
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  // グレースケール化
  for (let i = 0; i < data.length; i += 4) {
    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
    data[i] = data[i + 1] = data[i + 2] = gray;
  }

  // コントラスト強化（単純な2値化）
  const threshold = 128;
  for (let i = 0; i < data.length; i += 4) {
    const value = data[i] < threshold ? 0 : 255;
    data[i] = data[i + 1] = data[i + 2] = value;
  }

  ctx.putImageData(imageData, 0, 0);
  return canvas;
}
```

#### 3.1.3 選択範囲からのテキスト抽出

```typescript
// lib/ocr/selection.ts
export function extractTextInBounds(
  ocrResult: OCRResult,
  selection: { x: number; y: number; width: number; height: number }
): string {
  const selectedWords: OCRWord[] = [];

  for (const word of ocrResult.words) {
    const wordCenterX = word.bbox.x + word.bbox.width / 2;
    const wordCenterY = word.bbox.y + word.bbox.height / 2;

    // 単語の中心が選択範囲内にあるかチェック
    if (
      wordCenterX >= selection.x &&
      wordCenterX <= selection.x + selection.width &&
      wordCenterY >= selection.y &&
      wordCenterY <= selection.y + selection.height
    ) {
      selectedWords.push(word);
    }
  }

  // Y座標でソート → X座標でソート（左上から右下へ）
  selectedWords.sort((a, b) => {
    const yDiff = a.bbox.y - b.bbox.y;
    if (Math.abs(yDiff) > 10) {
      // 同じ行と見なす閾値
      return yDiff;
    }
    return a.bbox.x - b.bbox.x;
  });

  return selectedWords.map((w) => w.text).join('');
}
```

### 3.2 フロントエンドコンポーネント

```tsx
// app/(main)/components/OCRTextSelector.tsx
'use client';

import { useState, useRef, useEffect } from 'react';
import { performOCR, OCRResult, extractTextInBounds } from '@/lib/ocr';

interface OCRTextSelectorProps {
  imageFile: File;
  onTextsSelected: (texts: string[]) => void;
  onCancel: () => void;
}

export default function OCRTextSelector({
  imageFile,
  onTextsSelected,
  onCancel,
}: OCRTextSelectorProps) {
  const [imageUrl, setImageUrl] = useState<string>('');
  const [ocrResult, setOcrResult] = useState<OCRResult | null>(null);
  const [selectedTexts, setSelectedTexts] = useState<string[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [selection, setSelection] = useState<{
    startX: number;
    startY: number;
    endX: number;
    endY: number;
  } | null>(null);

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const processImage = async () => {
      setIsProcessing(true);

      // 画像をBase64に変換
      const reader = new FileReader();
      reader.onload = async (e) => {
        const base64 = e.target?.result as string;
        setImageUrl(base64);

        // OCR実行
        try {
          const result = await performOCR(base64);
          setOcrResult(result);
        } catch (error) {
          console.error('OCR error:', error);
          alert('OCR処理に失敗しました');
        } finally {
          setIsProcessing(false);
        }
      };
      reader.readAsDataURL(imageFile);
    };

    processImage();
  }, [imageFile]);

  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!ocrResult) return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setIsDragging(true);
    setSelection({ startX: x, startY: y, endX: x, endY: y });
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDragging || !selection) return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setSelection({ ...selection, endX: x, endY: y });

    // 選択範囲を描画
    drawSelection();
  };

  const handleMouseUp = () => {
    if (!isDragging || !selection || !ocrResult) return;

    setIsDragging(false);

    // 選択範囲のテキストを抽出
    const bounds = {
      x: Math.min(selection.startX, selection.endX),
      y: Math.min(selection.startY, selection.endY),
      width: Math.abs(selection.endX - selection.startX),
      height: Math.abs(selection.endY - selection.startY),
    };

    const text = extractTextInBounds(ocrResult, bounds);

    if (text) {
      setSelectedTexts([...selectedTexts, text]);
    }

    setSelection(null);
  };

  const drawSelection = () => {
    if (!canvasRef.current || !selection) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d')!;

    // 画像を再描画
    if (imgRef.current) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(imgRef.current, 0, 0, canvas.width, canvas.height);
    }

    // 選択範囲を描画
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      Math.min(selection.startX, selection.endX),
      Math.min(selection.startY, selection.endY),
      Math.abs(selection.endX - selection.startX),
      Math.abs(selection.endY - selection.startY)
    );
  };

  const removeText = (index: number) => {
    setSelectedTexts(selectedTexts.filter((_, i) => i !== index));
  };

  return (
    <div className="ocr-selector">
      {isProcessing && (
        <div className="loading">
          <p>OCR処理中...</p>
        </div>
      )}

      {!isProcessing && imageUrl && (
        <>
          <p className="hint">💡 画像をなぞって文字を選択してください</p>

          <div className="canvas-container">
            <img
              ref={imgRef}
              src={imageUrl}
              alt="OCR対象"
              style={{ display: 'none' }}
              onLoad={(e) => {
                const img = e.target as HTMLImageElement;
                const canvas = canvasRef.current!;
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d')!;
                ctx.drawImage(img, 0, 0);
              }}
            />

            <canvas
              ref={canvasRef}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              className="cursor-crosshair border"
            />
          </div>

          <div className="selected-texts mt-4">
            <h3 className="font-bold mb-2">選択済みテキスト:</h3>
            {selectedTexts.map((text, i) => (
              <div key={i} className="text-item flex items-center gap-2 p-2 bg-gray-100 rounded mb-2">
                <span className="flex-1">{i + 1}. {text}</span>
                <button
                  onClick={() => removeText(i)}
                  className="text-red-600 hover:text-red-800"
                >
                  削除
                </button>
              </div>
            ))}
          </div>

          <div className="actions mt-4 flex gap-2">
            <button onClick={onCancel} className="btn-secondary">
              戻る
            </button>
            <button
              onClick={() => onTextsSelected(selectedTexts)}
              className="btn-primary"
              disabled={selectedTexts.length === 0}
            >
              これらで登録を続ける
            </button>
          </div>
        </>
      )}
    </div>
  );
}
```

---

## 4. Amazon書籍情報取得

### 4.1 Webスクレイピング実装

```typescript
// lib/scraping/amazon.ts
import * as cheerio from 'cheerio';

export interface AmazonBookInfo {
  title: string;
  author: string;
  cover_image_url: string;
  isbn?: string;
  asin: string;
  publisher?: string;
}

export async function fetchAmazonBookInfo(url: string): Promise<AmazonBookInfo | null> {
  try {
    // URLからASINを抽出
    const asin = extractASIN(url);
    if (!asin) {
      throw new Error('Invalid Amazon URL');
    }

    // Amazonページを取得
    const response = await fetch(`https://www.amazon.co.jp/dp/${asin}`, {
      headers: {
        'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept-Language': 'ja-JP,ja;q=0.9',
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch Amazon page');
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // タイトル
    const title =
      $('#productTitle').text().trim() || $('#ebooksProductTitle').text().trim();

    // 著者
    const author =
      $('.author .contributorNameID').first().text().trim() ||
      $('#bylineInfo .author a').first().text().trim();

    // 書籍カバー画像
    const coverImageUrl =
      $('#landingImage').attr('src') || $('#ebooksImgBlkFront').attr('src') || '';

    // ISBN
    let isbn: string | undefined;
    $('#detailBullets_feature_div li, #detailBulletsWrapper_feature_div li').each(
      (_, el) => {
        const text = $(el).text();
        if (text.includes('ISBN-13')) {
          isbn = text.split(':')[1]?.trim().replace(/-/g, '');
        }
      }
    );

    // 出版社
    let publisher: string | undefined;
    $('#detailBullets_feature_div li, #detailBulletsWrapper_feature_div li').each(
      (_, el) => {
        const text = $(el).text();
        if (text.includes('出版社')) {
          publisher = text.split(':')[1]?.trim().split('(')[0].trim();
        }
      }
    );

    return {
      title,
      author,
      cover_image_url: coverImageUrl,
      isbn,
      asin,
      publisher,
    };
  } catch (error) {
    console.error('Amazon scraping error:', error);
    return null;
  }
}

function extractASIN(url: string): string | null {
  const patterns = [
    /\/dp\/([A-Z0-9]{10})/,
    /\/product\/([A-Z0-9]{10})/,
    /\/gp\/product\/([A-Z0-9]{10})/,
    /amazon\.co\.jp\/([A-Z0-9]{10})/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }

  return null;
}
```

### 4.2 レート制限対策

```typescript
// lib/scraping/rate-limiter.ts
export class RateLimiter {
  private requests: Map<string, number[]> = new Map();
  private maxRequests: number;
  private timeWindow: number; // ミリ秒

  constructor(maxRequests: number = 10, timeWindow: number = 60000) {
    this.maxRequests = maxRequests;
    this.timeWindow = timeWindow;
  }

  async checkLimit(key: string): Promise<boolean> {
    const now = Date.now();
    const requests = this.requests.get(key) || [];

    // 時間枠外のリクエストを削除
    const validRequests = requests.filter((time) => now - time < this.timeWindow);

    if (validRequests.length >= this.maxRequests) {
      return false; // レート制限超過
    }

    validRequests.push(now);
    this.requests.set(key, validRequests);

    return true;
  }

  async waitForSlot(key: string): Promise<void> {
    while (!(await this.checkLimit(key))) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }
  }
}

export const amazonRateLimiter = new RateLimiter(10, 60000); // 10req/min
```

---

## 5. SNSユーザー情報取得

### 5.1 URLからユーザーID抽出

```typescript
// lib/scraping/sns-url-parser.ts
export interface ParsedSNSUrl {
  platform: 'X' | 'THREADS';
  handle: string;
  postId: string;
}

export function parseSNSUrl(url: string): ParsedSNSUrl | null {
  // X (Twitter)
  const xPattern = /(?:twitter|x)\.com\/([^/]+)\/status\/(\d+)/;
  const xMatch = url.match(xPattern);
  if (xMatch) {
    return {
      platform: 'X',
      handle: xMatch[1],
      postId: xMatch[2],
    };
  }

  // Threads
  const threadsPattern = /threads\.net\/@([^/]+)\/post\/([A-Za-z0-9_-]+)/;
  const threadsMatch = url.match(threadsPattern);
  if (threadsMatch) {
    return {
      platform: 'THREADS',
      handle: threadsMatch[1],
      postId: threadsMatch[2],
    };
  }

  return null;
}
```

### 5.2 Google検索でユーザー名取得

```typescript
// lib/scraping/google-search.ts
import * as cheerio from 'cheerio';

export async function searchUserDisplayName(
  platform: string,
  handle: string
): Promise<string | null> {
  try {
    const query = `${platform} ${handle}`;
    const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`;

    const response = await fetch(searchUrl, {
      headers: {
        'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept-Language': 'ja-JP,ja;q=0.9',
      },
    });

    const html = await response.text();
    const $ = cheerio.load(html);

    // 検索結果から「ユーザー名 (@handle)」のパターンを探す
    let displayName: string | null = null;

    $('h3, .g').each((_, el) => {
      const text = $(el).text();
      const pattern = new RegExp(`([^(]+)\\s*\\(@${handle}\\)`);
      const match = text.match(pattern);
      if (match) {
        displayName = match[1].trim();
        return false; // break
      }
    });

    return displayName;
  } catch (error) {
    console.error('Google search error:', error);
    return null;
  }
}
```

**注意:** Google検索のスクレイピングは利用規約でグレーゾーン。商用利用の場合は SerpAPI や Google Custom Search API の使用を推奨。

### 5.3 SerpAPI使用例（推奨）

```typescript
// lib/scraping/serp-api.ts
export async function searchUserDisplayNameWithSerpAPI(
  platform: string,
  handle: string
): Promise<string | null> {
  const apiKey = process.env.SERPAPI_KEY;
  if (!apiKey) {
    throw new Error('SERPAPI_KEY is not set');
  }

  const query = `${platform} ${handle}`;
  const url = `https://serpapi.com/search?q=${encodeURIComponent(query)}&api_key=${apiKey}`;

  const response = await fetch(url);
  const data = await response.json();

  // 検索結果からユーザー名を抽出
  for (const result of data.organic_results || []) {
    const text = result.title + ' ' + result.snippet;
    const pattern = new RegExp(`([^(]+)\\s*\\(@${handle}\\)`);
    const match = text.match(pattern);
    if (match) {
      return match[1].trim();
    }
  }

  return null;
}
```

---

## 6. CSVエクスポート

```typescript
// lib/utils/csv-export.ts
export interface QuoteForCSV {
  text: string;
  source: string;
  activities: string;
  tags: string;
  created_at: string;
}

export function generateCSV(quotes: QuoteForCSV[]): string {
  const header = ['フレーズ', '出典', '活動領域', 'タグ', '登録日時'];

  const rows = quotes.map((quote) => [
    escapeCsvCell(quote.text),
    escapeCsvCell(quote.source),
    escapeCsvCell(quote.activities),
    escapeCsvCell(quote.tags),
    escapeCsvCell(quote.created_at),
  ]);

  const csvContent = [header, ...rows].map((row) => row.join(',')).join('\n');

  // BOM付きUTF-8（Excelで文字化け防止）
  return '\uFEFF' + csvContent;
}

function escapeCsvCell(value: string): string {
  // ダブルクォートをエスケープ
  const escaped = value.replace(/"/g, '""');

  // カンマ、改行、ダブルクォートを含む場合はダブルクォートで囲む
  if (escaped.includes(',') || escaped.includes('\n') || escaped.includes('"')) {
    return `"${escaped}"`;
  }

  return escaped;
}

export function downloadCSV(csv: string, filename: string) {
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
```

---

## 7. 認証

### 7.1 Supabase Auth設定

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

```typescript
// lib/supabase/server.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';

export function createClient() {
  const cookieStore = cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}
```

### 7.2 ミドルウェア

```typescript
// middleware.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({ name, value: '', ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: '', ...options });
        },
      },
    }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // 未認証ユーザーをログインページにリダイレクト
  if (!user && !request.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // 認証済みユーザーがログインページにアクセスした場合はホームにリダイレクト
  if (user && request.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.redirect(new URL('/', request.url));
  }

  return response;
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
};
```

---

## 8. 環境変数

```env
# .env.local

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJxxx...

# SerpAPI（オプション）
SERPAPI_KEY=xxx

# 開発環境設定
NODE_ENV=development
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

---

## 9. デプロイ

### 9.1 Vercel設定

```json
// vercel.json
{
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "framework": "nextjs",
  "regions": ["hnd1"]
}
```

### 9.2 環境変数設定

Vercelダッシュボードで以下を設定:
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SERPAPI_KEY`（オプション）

---

## 10. パフォーマンス最適化

### 10.1 画像最適化
- Next.js の `<Image>` コンポーネント使用
- 書籍カバー画像を WebP 形式で配信
- Lazy loading

### 10.2 キャッシュ戦略
- OCR結果をブラウザキャッシュ（5分）
- 活動領域マスタをクライアント側キャッシュ
- Supabase クエリキャッシュ

### 10.3 無限スクロール
- Intersection Observer API使用
- 初回50件、追加20件ずつ読み込み

---

## 11. セキュリティ

### 11.1 XSS対策
- React の自動エスケープ
- `dangerouslySetInnerHTML` は使用しない

### 11.2 CSRF対策
- Supabase Auth の CSRF トークン

### 11.3 レート制限
- API Routes でレート制限実装
- Redis または Vercel KV 使用

---

## 12. テスト

### 12.1 単体テスト（Vitest）

```typescript
// lib/ocr/__tests__/selection.test.ts
import { describe, it, expect } from 'vitest';
import { extractTextInBounds } from '../selection';

describe('extractTextInBounds', () => {
  it('should extract text within bounds', () => {
    const ocrResult = {
      text: '集中は筋肉のように鍛えられる。',
      words: [
        { text: '集中', confidence: 0.95, bbox: { x: 100, y: 200, width: 50, height: 20 } },
        { text: 'は', confidence: 0.98, bbox: { x: 155, y: 200, width: 20, height: 20 } },
        // ...
      ],
      lines: [],
    };

    const selection = { x: 95, y: 195, width: 100, height: 30 };
    const result = extractTextInBounds(ocrResult, selection);

    expect(result).toBe('集中は');
  });
});
```

### 12.2 E2Eテスト（Playwright）

```typescript
// e2e/quote-registration.spec.ts
import { test, expect } from '@playwright/test';

test('フレーズを登録できる', async ({ page }) => {
  await page.goto('/');

  // ログイン
  await page.click('text=ログイン');
  // ... 認証フロー

  // フレーズ登録モーダルを開く
  await page.click('button:has-text("+ 新規登録")');

  // フレーズを入力
  await page.fill('textarea[name="quote-text"]', '集中は筋肉のように鍛えられる。');

  // 活動領域を選択
  await page.check('input[value="2"]'); // 学習・研究

  // タグを追加
  await page.fill('input[name="new-tag"]', '集中');
  await page.click('button:has-text("+ 追加")');

  // 出典タイプを選択
  await page.click('input[value="BOOK"]');

  // 登録
  await page.click('button:has-text("登録する")');

  // 確認
  await expect(page.locator('text=集中は筋肉のように鍛えられる。')).toBeVisible();
});
```

---

## 13. 変更履歴

| バージョン | 日付 | 変更内容 | 担当者 |
|-----------|------|----------|--------|
| 1.0 | 2024-10-27 | 初版作成 | - |
| 2.0 | 2024-10-27 | 活動領域固定、アイコン画像削除、Google検索でユーザー名取得 | - |
