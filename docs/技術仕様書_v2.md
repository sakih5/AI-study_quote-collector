# æŠ€è¡“ä»•æ§˜æ›¸ v2.0

## 1. ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### 1.1 æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

#### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
- **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: Next.js 14 (App Router)
- **è¨€èª**: TypeScript 5.x
- **UIãƒ©ã‚¤ãƒ–ãƒ©ãƒª**: Tailwind CSS 3.x
- **çŠ¶æ…‹ç®¡ç†**: React Context API + hooks
- **ãƒ•ã‚©ãƒ¼ãƒ ç®¡ç†**: React Hook Form
- **ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³**: Zod
- **OCR**: Tesseract.js 5.x

#### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
- **BaaS**: Supabase (PostgreSQL 15)
- **èªè¨¼**: Supabase Auth
- **ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸**: Supabase Storage
- **API**: Next.js API Routes

#### ã‚¤ãƒ³ãƒ•ãƒ©
- **ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°**: Vercel
- **ãƒ‰ãƒ¡ã‚¤ãƒ³**: Vercel Domains
- **CDN**: Vercel Edge Network

#### é–‹ç™ºãƒ„ãƒ¼ãƒ«
- **ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ç®¡ç†**: npm / pnpm
- **ãƒªãƒ³ã‚¿ãƒ¼**: ESLint
- **ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼**: Prettier
- **ãƒ†ã‚¹ãƒˆ**: Vitest (å˜ä½“ãƒ†ã‚¹ãƒˆ), Playwright (E2E)
- **CI/CD**: GitHub Actions

---

## 2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ

### 2.1 ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
æŠœãæ›¸ãã‚¢ãƒ—ãƒª/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ (auth)/
â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â””â”€â”€ callback/
â”‚   â”œâ”€â”€ (main)/
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”œâ”€â”€ page.tsx              # ãƒ›ãƒ¼ãƒ ç”»é¢
â”‚   â”‚   â”œâ”€â”€ settings/
â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx          # è¨­å®šç”»é¢
â”‚   â”‚   â”‚   â””â”€â”€ tags/
â”‚   â”‚   â”‚       â””â”€â”€ page.tsx      # ã‚¿ã‚°ç®¡ç†ç”»é¢
â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ QuoteCard.tsx
â”‚   â”‚       â”œâ”€â”€ QuoteModal.tsx
â”‚   â”‚       â”œâ”€â”€ OCRTextSelector.tsx
â”‚   â”‚       â””â”€â”€ ...
â”‚   â””â”€â”€ api/
â”‚       â”œâ”€â”€ activities/
â”‚       â”œâ”€â”€ books/
â”‚       â”œâ”€â”€ sns-users/
â”‚       â”œâ”€â”€ tags/
â”‚       â”œâ”€â”€ quotes/
â”‚       â”œâ”€â”€ ocr/
â”‚       â””â”€â”€ export/
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ supabase/
â”‚   â”‚   â”œâ”€â”€ client.ts
â”‚   â”‚   â”œâ”€â”€ server.ts
â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”œâ”€â”€ ocr/
â”‚   â”‚   â””â”€â”€ tesseract.ts
â”‚   â”œâ”€â”€ scraping/
â”‚   â”‚   â”œâ”€â”€ amazon.ts
â”‚   â”‚   â””â”€â”€ google-search.ts
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ csv-export.ts
â”‚       â””â”€â”€ validators.ts
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ui/                       # å…±é€šUIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ layouts/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ public/
â”‚   â””â”€â”€ assets/
â”œâ”€â”€ styles/
â”‚   â””â”€â”€ globals.css
â”œâ”€â”€ types/
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ .env.local
â”œâ”€â”€ .eslintrc.json
â”œâ”€â”€ .prettierrc
â”œâ”€â”€ next.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

---

## 3. OCRå®Ÿè£…

### 3.1 Tesseract.js

#### 3.1.1 åŸºæœ¬å®Ÿè£…

```typescript
// lib/ocr/tesseract.ts
import Tesseract from 'tesseract.js';

export interface OCRWord {
  text: string;
  confidence: number;
  bbox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
}

export interface OCRLine {
  text: string;
  bbox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  words: OCRWord[];
}

export interface OCRResult {
  text: string;
  words: OCRWord[];
  lines: OCRLine[];
}

export async function performOCR(
  imageUrl: string,
  language: string = 'jpn'
): Promise<OCRResult> {
  const { data } = await Tesseract.recognize(imageUrl, language, {
    logger: (m) => {
      if (m.status === 'recognizing text') {
        console.log(`OCRé€²è¡Œä¸­: ${Math.round(m.progress * 100)}%`);
      }
    },
  });

  return {
    text: data.text,
    words: data.words.map((w) => ({
      text: w.text,
      confidence: w.confidence / 100,
      bbox: w.bbox,
    })),
    lines: data.lines.map((l) => ({
      text: l.text,
      bbox: l.bbox,
      words: l.words.map((w) => ({
        text: w.text,
        confidence: w.confidence / 100,
        bbox: w.bbox,
      })),
    })),
  };
}
```

#### 3.1.2 ç”»åƒå‰å‡¦ç†ï¼ˆç²¾åº¦å‘ä¸Šï¼‰

```typescript
// lib/ocr/preprocess.ts
export function preprocessImage(canvas: HTMLCanvasElement): HTMLCanvasElement {
  const ctx = canvas.getContext('2d')!;
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  // ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«åŒ–
  for (let i = 0; i < data.length; i += 4) {
    const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
    data[i] = data[i + 1] = data[i + 2] = gray;
  }

  // ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆå¼·åŒ–ï¼ˆå˜ç´”ãª2å€¤åŒ–ï¼‰
  const threshold = 128;
  for (let i = 0; i < data.length; i += 4) {
    const value = data[i] < threshold ? 0 : 255;
    data[i] = data[i + 1] = data[i + 2] = value;
  }

  ctx.putImageData(imageData, 0, 0);
  return canvas;
}
```

#### 3.1.3 é¸æŠç¯„å›²ã‹ã‚‰ã®ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º

```typescript
// lib/ocr/selection.ts
export function extractTextInBounds(
  ocrResult: OCRResult,
  selection: { x: number; y: number; width: number; height: number }
): string {
  const selectedWords: OCRWord[] = [];

  for (const word of ocrResult.words) {
    const wordCenterX = word.bbox.x + word.bbox.width / 2;
    const wordCenterY = word.bbox.y + word.bbox.height / 2;

    // å˜èªã®ä¸­å¿ƒãŒé¸æŠç¯„å›²å†…ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (
      wordCenterX >= selection.x &&
      wordCenterX <= selection.x + selection.width &&
      wordCenterY >= selection.y &&
      wordCenterY <= selection.y + selection.height
    ) {
      selectedWords.push(word);
    }
  }

  // Yåº§æ¨™ã§ã‚½ãƒ¼ãƒˆ â†’ Xåº§æ¨™ã§ã‚½ãƒ¼ãƒˆï¼ˆå·¦ä¸Šã‹ã‚‰å³ä¸‹ã¸ï¼‰
  selectedWords.sort((a, b) => {
    const yDiff = a.bbox.y - b.bbox.y;
    if (Math.abs(yDiff) > 10) {
      // åŒã˜è¡Œã¨è¦‹ãªã™é–¾å€¤
      return yDiff;
    }
    return a.bbox.x - b.bbox.x;
  });

  return selectedWords.map((w) => w.text).join('');
}
```

### 3.2 ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```tsx
// app/(main)/components/OCRTextSelector.tsx
'use client';

import { useState, useRef, useEffect } from 'react';
import { performOCR, OCRResult, extractTextInBounds } from '@/lib/ocr';

interface OCRTextSelectorProps {
  imageFile: File;
  onTextsSelected: (texts: string[]) => void;
  onCancel: () => void;
}

export default function OCRTextSelector({
  imageFile,
  onTextsSelected,
  onCancel,
}: OCRTextSelectorProps) {
  const [imageUrl, setImageUrl] = useState<string>('');
  const [ocrResult, setOcrResult] = useState<OCRResult | null>(null);
  const [selectedTexts, setSelectedTexts] = useState<string[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [selection, setSelection] = useState<{
    startX: number;
    startY: number;
    endX: number;
    endY: number;
  } | null>(null);

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const processImage = async () => {
      setIsProcessing(true);

      // ç”»åƒã‚’Base64ã«å¤‰æ›
      const reader = new FileReader();
      reader.onload = async (e) => {
        const base64 = e.target?.result as string;
        setImageUrl(base64);

        // OCRå®Ÿè¡Œ
        try {
          const result = await performOCR(base64);
          setOcrResult(result);
        } catch (error) {
          console.error('OCR error:', error);
          alert('OCRå‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ');
        } finally {
          setIsProcessing(false);
        }
      };
      reader.readAsDataURL(imageFile);
    };

    processImage();
  }, [imageFile]);

  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!ocrResult) return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setIsDragging(true);
    setSelection({ startX: x, startY: y, endX: x, endY: y });
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDragging || !selection) return;

    const rect = canvasRef.current!.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setSelection({ ...selection, endX: x, endY: y });

    // é¸æŠç¯„å›²ã‚’æç”»
    drawSelection();
  };

  const handleMouseUp = () => {
    if (!isDragging || !selection || !ocrResult) return;

    setIsDragging(false);

    // é¸æŠç¯„å›²ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º
    const bounds = {
      x: Math.min(selection.startX, selection.endX),
      y: Math.min(selection.startY, selection.endY),
      width: Math.abs(selection.endX - selection.startX),
      height: Math.abs(selection.endY - selection.startY),
    };

    const text = extractTextInBounds(ocrResult, bounds);

    if (text) {
      setSelectedTexts([...selectedTexts, text]);
    }

    setSelection(null);
  };

  const drawSelection = () => {
    if (!canvasRef.current || !selection) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d')!;

    // ç”»åƒã‚’å†æç”»
    if (imgRef.current) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(imgRef.current, 0, 0, canvas.width, canvas.height);
    }

    // é¸æŠç¯„å›²ã‚’æç”»
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.strokeRect(
      Math.min(selection.startX, selection.endX),
      Math.min(selection.startY, selection.endY),
      Math.abs(selection.endX - selection.startX),
      Math.abs(selection.endY - selection.startY)
    );
  };

  const removeText = (index: number) => {
    setSelectedTexts(selectedTexts.filter((_, i) => i !== index));
  };

  return (
    <div className="ocr-selector">
      {isProcessing && (
        <div className="loading">
          <p>OCRå‡¦ç†ä¸­...</p>
        </div>
      )}

      {!isProcessing && imageUrl && (
        <>
          <p className="hint">ğŸ’¡ ç”»åƒã‚’ãªãã£ã¦æ–‡å­—ã‚’é¸æŠã—ã¦ãã ã•ã„</p>

          <div className="canvas-container">
            <img
              ref={imgRef}
              src={imageUrl}
              alt="OCRå¯¾è±¡"
              style={{ display: 'none' }}
              onLoad={(e) => {
                const img = e.target as HTMLImageElement;
                const canvas = canvasRef.current!;
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d')!;
                ctx.drawImage(img, 0, 0);
              }}
            />

            <canvas
              ref={canvasRef}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              className="cursor-crosshair border"
            />
          </div>

          <div className="selected-texts mt-4">
            <h3 className="font-bold mb-2">é¸æŠæ¸ˆã¿ãƒ†ã‚­ã‚¹ãƒˆ:</h3>
            {selectedTexts.map((text, i) => (
              <div key={i} className="text-item flex items-center gap-2 p-2 bg-gray-100 rounded mb-2">
                <span className="flex-1">{i + 1}. {text}</span>
                <button
                  onClick={() => removeText(i)}
                  className="text-red-600 hover:text-red-800"
                >
                  å‰Šé™¤
                </button>
              </div>
            ))}
          </div>

          <div className="actions mt-4 flex gap-2">
            <button onClick={onCancel} className="btn-secondary">
              æˆ»ã‚‹
            </button>
            <button
              onClick={() => onTextsSelected(selectedTexts)}
              className="btn-primary"
              disabled={selectedTexts.length === 0}
            >
              ã“ã‚Œã‚‰ã§ç™»éŒ²ã‚’ç¶šã‘ã‚‹
            </button>
          </div>
        </>
      )}
    </div>
  );
}
```

---

## 4. Amazonæ›¸ç±æƒ…å ±å–å¾—

### 4.1 Webã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å®Ÿè£…

```typescript
// lib/scraping/amazon.ts
import * as cheerio from 'cheerio';

export interface AmazonBookInfo {
  title: string;
  author: string;
  cover_image_url: string;
  isbn?: string;
  asin: string;
  publisher?: string;
}

export async function fetchAmazonBookInfo(url: string): Promise<AmazonBookInfo | null> {
  try {
    // URLã‹ã‚‰ASINã‚’æŠ½å‡º
    const asin = extractASIN(url);
    if (!asin) {
      throw new Error('Invalid Amazon URL');
    }

    // Amazonãƒšãƒ¼ã‚¸ã‚’å–å¾—
    const response = await fetch(`https://www.amazon.co.jp/dp/${asin}`, {
      headers: {
        'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept-Language': 'ja-JP,ja;q=0.9',
      },
    });

    if (!response.ok) {
      throw new Error('Failed to fetch Amazon page');
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // ã‚¿ã‚¤ãƒˆãƒ«
    const title =
      $('#productTitle').text().trim() || $('#ebooksProductTitle').text().trim();

    // è‘—è€…
    const author =
      $('.author .contributorNameID').first().text().trim() ||
      $('#bylineInfo .author a').first().text().trim();

    // æ›¸ç±ã‚«ãƒãƒ¼ç”»åƒ
    const coverImageUrl =
      $('#landingImage').attr('src') || $('#ebooksImgBlkFront').attr('src') || '';

    // ISBN
    let isbn: string | undefined;
    $('#detailBullets_feature_div li, #detailBulletsWrapper_feature_div li').each(
      (_, el) => {
        const text = $(el).text();
        if (text.includes('ISBN-13')) {
          isbn = text.split(':')[1]?.trim().replace(/-/g, '');
        }
      }
    );

    // å‡ºç‰ˆç¤¾
    let publisher: string | undefined;
    $('#detailBullets_feature_div li, #detailBulletsWrapper_feature_div li').each(
      (_, el) => {
        const text = $(el).text();
        if (text.includes('å‡ºç‰ˆç¤¾')) {
          publisher = text.split(':')[1]?.trim().split('(')[0].trim();
        }
      }
    );

    return {
      title,
      author,
      cover_image_url: coverImageUrl,
      isbn,
      asin,
      publisher,
    };
  } catch (error) {
    console.error('Amazon scraping error:', error);
    return null;
  }
}

function extractASIN(url: string): string | null {
  const patterns = [
    /\/dp\/([A-Z0-9]{10})/,
    /\/product\/([A-Z0-9]{10})/,
    /\/gp\/product\/([A-Z0-9]{10})/,
    /amazon\.co\.jp\/([A-Z0-9]{10})/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return match[1];
    }
  }

  return null;
}
```

### 4.2 ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–

```typescript
// lib/scraping/rate-limiter.ts
export class RateLimiter {
  private requests: Map<string, number[]> = new Map();
  private maxRequests: number;
  private timeWindow: number; // ãƒŸãƒªç§’

  constructor(maxRequests: number = 10, timeWindow: number = 60000) {
    this.maxRequests = maxRequests;
    this.timeWindow = timeWindow;
  }

  async checkLimit(key: string): Promise<boolean> {
    const now = Date.now();
    const requests = this.requests.get(key) || [];

    // æ™‚é–“æ å¤–ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‰Šé™¤
    const validRequests = requests.filter((time) => now - time < this.timeWindow);

    if (validRequests.length >= this.maxRequests) {
      return false; // ãƒ¬ãƒ¼ãƒˆåˆ¶é™è¶…é
    }

    validRequests.push(now);
    this.requests.set(key, validRequests);

    return true;
  }

  async waitForSlot(key: string): Promise<void> {
    while (!(await this.checkLimit(key))) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }
  }
}

export const amazonRateLimiter = new RateLimiter(10, 60000); // 10req/min
```

---

## 5. SNSãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—

### 5.1 URLã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼IDæŠ½å‡º

```typescript
// lib/scraping/sns-url-parser.ts
export interface ParsedSNSUrl {
  platform: 'X' | 'THREADS';
  handle: string;
  postId: string;
}

export function parseSNSUrl(url: string): ParsedSNSUrl | null {
  // X (Twitter)
  const xPattern = /(?:twitter|x)\.com\/([^/]+)\/status\/(\d+)/;
  const xMatch = url.match(xPattern);
  if (xMatch) {
    return {
      platform: 'X',
      handle: xMatch[1],
      postId: xMatch[2],
    };
  }

  // Threads
  const threadsPattern = /threads\.net\/@([^/]+)\/post\/([A-Za-z0-9_-]+)/;
  const threadsMatch = url.match(threadsPattern);
  if (threadsMatch) {
    return {
      platform: 'THREADS',
      handle: threadsMatch[1],
      postId: threadsMatch[2],
    };
  }

  return null;
}
```

### 5.2 Googleæ¤œç´¢ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼åå–å¾—

```typescript
// lib/scraping/google-search.ts
import * as cheerio from 'cheerio';

export async function searchUserDisplayName(
  platform: string,
  handle: string
): Promise<string | null> {
  try {
    const query = `${platform} ${handle}`;
    const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`;

    const response = await fetch(searchUrl, {
      headers: {
        'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept-Language': 'ja-JP,ja;q=0.9',
      },
    });

    const html = await response.text();
    const $ = cheerio.load(html);

    // æ¤œç´¢çµæœã‹ã‚‰ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼å (@handle)ã€ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™
    let displayName: string | null = null;

    $('h3, .g').each((_, el) => {
      const text = $(el).text();
      const pattern = new RegExp(`([^(]+)\\s*\\(@${handle}\\)`);
      const match = text.match(pattern);
      if (match) {
        displayName = match[1].trim();
        return false; // break
      }
    });

    return displayName;
  } catch (error) {
    console.error('Google search error:', error);
    return null;
  }
}
```

**æ³¨æ„:** Googleæ¤œç´¢ã®ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°ã¯åˆ©ç”¨è¦ç´„ã§ã‚°ãƒ¬ãƒ¼ã‚¾ãƒ¼ãƒ³ã€‚å•†ç”¨åˆ©ç”¨ã®å ´åˆã¯ SerpAPI ã‚„ Google Custom Search API ã®ä½¿ç”¨ã‚’æ¨å¥¨ã€‚

### 5.3 SerpAPIä½¿ç”¨ä¾‹ï¼ˆæ¨å¥¨ï¼‰

```typescript
// lib/scraping/serp-api.ts
export async function searchUserDisplayNameWithSerpAPI(
  platform: string,
  handle: string
): Promise<string | null> {
  const apiKey = process.env.SERPAPI_KEY;
  if (!apiKey) {
    throw new Error('SERPAPI_KEY is not set');
  }

  const query = `${platform} ${handle}`;
  const url = `https://serpapi.com/search?q=${encodeURIComponent(query)}&api_key=${apiKey}`;

  const response = await fetch(url);
  const data = await response.json();

  // æ¤œç´¢çµæœã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’æŠ½å‡º
  for (const result of data.organic_results || []) {
    const text = result.title + ' ' + result.snippet;
    const pattern = new RegExp(`([^(]+)\\s*\\(@${handle}\\)`);
    const match = text.match(pattern);
    if (match) {
      return match[1].trim();
    }
  }

  return null;
}
```

---

## 6. CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ

```typescript
// lib/utils/csv-export.ts
export interface QuoteForCSV {
  text: string;
  source: string;
  activities: string;
  tags: string;
  created_at: string;
}

export function generateCSV(quotes: QuoteForCSV[]): string {
  const header = ['ãƒ•ãƒ¬ãƒ¼ã‚º', 'å‡ºå…¸', 'æ´»å‹•é ˜åŸŸ', 'ã‚¿ã‚°', 'ç™»éŒ²æ—¥æ™‚'];

  const rows = quotes.map((quote) => [
    escapeCsvCell(quote.text),
    escapeCsvCell(quote.source),
    escapeCsvCell(quote.activities),
    escapeCsvCell(quote.tags),
    escapeCsvCell(quote.created_at),
  ]);

  const csvContent = [header, ...rows].map((row) => row.join(',')).join('\n');

  // BOMä»˜ãUTF-8ï¼ˆExcelã§æ–‡å­—åŒ–ã‘é˜²æ­¢ï¼‰
  return '\uFEFF' + csvContent;
}

function escapeCsvCell(value: string): string {
  // ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
  const escaped = value.replace(/"/g, '""');

  // ã‚«ãƒ³ãƒã€æ”¹è¡Œã€ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã‚’å«ã‚€å ´åˆã¯ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã§å›²ã‚€
  if (escaped.includes(',') || escaped.includes('\n') || escaped.includes('"')) {
    return `"${escaped}"`;
  }

  return escaped;
}

export function downloadCSV(csv: string, filename: string) {
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
```

---

## 7. èªè¨¼

### 7.1 Supabase Authè¨­å®š

```typescript
// lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

```typescript
// lib/supabase/server.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';

export function createClient() {
  const cookieStore = cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}
```

### 7.2 ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢

```typescript
// middleware.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({ name, value, ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value, ...options });
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({ name, value: '', ...options });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({ name, value: '', ...options });
        },
      },
    }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  // æœªèªè¨¼ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
  if (!user && !request.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // èªè¨¼æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸå ´åˆã¯ãƒ›ãƒ¼ãƒ ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
  if (user && request.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.redirect(new URL('/', request.url));
  }

  return response;
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
};
```

---

## 8. ç’°å¢ƒå¤‰æ•°

```env
# .env.local

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJxxx...

# SerpAPIï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
SERPAPI_KEY=xxx

# é–‹ç™ºç’°å¢ƒè¨­å®š
NODE_ENV=development
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

---

## 9. ãƒ‡ãƒ—ãƒ­ã‚¤

### 9.1 Vercelè¨­å®š

```json
// vercel.json
{
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "framework": "nextjs",
  "regions": ["hnd1"]
}
```

### 9.2 ç’°å¢ƒå¤‰æ•°è¨­å®š

Vercelãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ä»¥ä¸‹ã‚’è¨­å®š:
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SERPAPI_KEY`ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

---

## 10. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### 10.1 ç”»åƒæœ€é©åŒ–
- Next.js ã® `<Image>` ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä½¿ç”¨
- æ›¸ç±ã‚«ãƒãƒ¼ç”»åƒã‚’ WebP å½¢å¼ã§é…ä¿¡
- Lazy loading

### 10.2 ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥
- OCRçµæœã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆ5åˆ†ï¼‰
- æ´»å‹•é ˜åŸŸãƒã‚¹ã‚¿ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã‚­ãƒ£ãƒƒã‚·ãƒ¥
- Supabase ã‚¯ã‚¨ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥

### 10.3 ç„¡é™ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
- Intersection Observer APIä½¿ç”¨
- åˆå›50ä»¶ã€è¿½åŠ 20ä»¶ãšã¤èª­ã¿è¾¼ã¿

---

## 11. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### 11.1 XSSå¯¾ç­–
- React ã®è‡ªå‹•ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
- `dangerouslySetInnerHTML` ã¯ä½¿ç”¨ã—ãªã„

### 11.2 CSRFå¯¾ç­–
- Supabase Auth ã® CSRF ãƒˆãƒ¼ã‚¯ãƒ³

### 11.3 ãƒ¬ãƒ¼ãƒˆåˆ¶é™
- API Routes ã§ãƒ¬ãƒ¼ãƒˆåˆ¶é™å®Ÿè£…
- Redis ã¾ãŸã¯ Vercel KV ä½¿ç”¨

---

## 12. ãƒ†ã‚¹ãƒˆ

### 12.1 å˜ä½“ãƒ†ã‚¹ãƒˆï¼ˆVitestï¼‰

```typescript
// lib/ocr/__tests__/selection.test.ts
import { describe, it, expect } from 'vitest';
import { extractTextInBounds } from '../selection';

describe('extractTextInBounds', () => {
  it('should extract text within bounds', () => {
    const ocrResult = {
      text: 'é›†ä¸­ã¯ç­‹è‚‰ã®ã‚ˆã†ã«é›ãˆã‚‰ã‚Œã‚‹ã€‚',
      words: [
        { text: 'é›†ä¸­', confidence: 0.95, bbox: { x: 100, y: 200, width: 50, height: 20 } },
        { text: 'ã¯', confidence: 0.98, bbox: { x: 155, y: 200, width: 20, height: 20 } },
        // ...
      ],
      lines: [],
    };

    const selection = { x: 95, y: 195, width: 100, height: 30 };
    const result = extractTextInBounds(ocrResult, selection);

    expect(result).toBe('é›†ä¸­ã¯');
  });
});
```

### 12.2 E2Eãƒ†ã‚¹ãƒˆï¼ˆPlaywrightï¼‰

```typescript
// e2e/quote-registration.spec.ts
import { test, expect } from '@playwright/test';

test('ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’ç™»éŒ²ã§ãã‚‹', async ({ page }) => {
  await page.goto('/');

  // ãƒ­ã‚°ã‚¤ãƒ³
  await page.click('text=ãƒ­ã‚°ã‚¤ãƒ³');
  // ... èªè¨¼ãƒ•ãƒ­ãƒ¼

  // ãƒ•ãƒ¬ãƒ¼ã‚ºç™»éŒ²ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
  await page.click('button:has-text("+ æ–°è¦ç™»éŒ²")');

  // ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’å…¥åŠ›
  await page.fill('textarea[name="quote-text"]', 'é›†ä¸­ã¯ç­‹è‚‰ã®ã‚ˆã†ã«é›ãˆã‚‰ã‚Œã‚‹ã€‚');

  // æ´»å‹•é ˜åŸŸã‚’é¸æŠ
  await page.check('input[value="2"]'); // å­¦ç¿’ãƒ»ç ”ç©¶

  // ã‚¿ã‚°ã‚’è¿½åŠ 
  await page.fill('input[name="new-tag"]', 'é›†ä¸­');
  await page.click('button:has-text("+ è¿½åŠ ")');

  // å‡ºå…¸ã‚¿ã‚¤ãƒ—ã‚’é¸æŠ
  await page.click('input[value="BOOK"]');

  // ç™»éŒ²
  await page.click('button:has-text("ç™»éŒ²ã™ã‚‹")');

  // ç¢ºèª
  await expect(page.locator('text=é›†ä¸­ã¯ç­‹è‚‰ã®ã‚ˆã†ã«é›ãˆã‚‰ã‚Œã‚‹ã€‚')).toBeVisible();
});
```

---

## 13. å¤‰æ›´å±¥æ­´

| ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | æ—¥ä»˜ | å¤‰æ›´å†…å®¹ | æ‹…å½“è€… |
|-----------|------|----------|--------|
| 1.0 | 2024-10-27 | åˆç‰ˆä½œæˆ | - |
| 2.0 | 2024-10-27 | æ´»å‹•é ˜åŸŸå›ºå®šã€ã‚¢ã‚¤ã‚³ãƒ³ç”»åƒå‰Šé™¤ã€Googleæ¤œç´¢ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼åå–å¾— | - |
